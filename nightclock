#!/usr/bin/env python

# 2022.02.16 v1.03.00
# 2022.01.31 v1.00

# todo:
# watering (Plant.water)

import pyglet
from pyglet.window import key
import datetime
import math
import random


def emptysub(*args,**kwargs): pass
phasemax = 1000

game_window = pyglet.window.Window(fullscreen=True) #1280, 960)
main_batch = pyglet.graphics.Batch()
plants_plane = pyglet.graphics.Group(order=0)
actors_plane = pyglet.graphics.Group(order=1)
clock_plane = pyglet.graphics.Group(order=2)

keyboard = key.KeyStateHandler()
game_window.push_handlers(keyboard)

@game_window.event
def on_draw():
    game_window.clear()
    main_batch.draw()

@game_window.event
def on_expose():
    on_draw()

next_y = (game_window.height)*2//3

time_label = pyglet.text.Label(
    text='00:00:00',
    font_size=72, color=(0,128,0,255),
    x = game_window.width//2,
    y = next_y,
    anchor_x='center', batch=main_batch, group=clock_plane)

big_font_size = 72*(game_window.width-64)/time_label.content_width
time_label.font_size = big_font_size

next_y += -32 - time_label.content_height//2

date_label = pyglet.text.Label(text='0000-00-00',
    font_size=big_font_size//3, color=(0,128,0,255),
    x=game_window.width//2, y=next_y,
    anchor_x='center', batch=main_batch, group=clock_plane)



class Plant:
    batch = main_batch
    group = plants_plane
    def __init__(self, x, y, height=0):
        self.__dict__.update( locals() )
        del self.__dict__['self']
        self.parts = []
        self.dead = False
        self.age = 0
        self.max_age = random.uniform(self.max_age*0.7, self.max_age*1.4)
        self.water = 0  #!!! implement watering
        self.need_water()
        self.stem = pyglet.shapes.Line(x, y, x, y+height, width=self.width,
            color=self.stemcolor, batch=self.batch, group=self.group)

    def delete(self):
        self.stem.delete()
        for i in self.parts:
            i.delete()

    def need_water(self):
        self.need = random.uniform(5,20)

class Flower(Plant):
    max_height = 20
    width = 2
    stemcolor = (0, 128, 0)
    centercolor = (255, 255, 0)
    leafcolor = (128, 128, 128)
    leaves_count = 7
    max_age = 600
    def __init__(self, *args):
        super().__init__(*args)
        self.blooming = False

    def bloom(self):
        x = self.x
        y = self.y+self.height
        w = self.width
        for i in range(self.leaves_count):
            angle = math.radians( 360*i//self.leaves_count )
            dx = self.width*4*math.cos(angle)
            dy = self.width*4*math.sin(angle)
            l = pyglet.shapes.Line(x, y, x+dx, y+dy, width=self.width*2,
                color=self.leafcolor, batch=self.batch, group=self.group)
            self.parts.append(l)
        self.parts.append( pyglet.shapes.Circle(x, y, w*2,
            color=self.centercolor, batch=self.batch, group=self.group) )
        self.blooming = True

    def grow(self, dt):
        self.need -= dt
        if self.need < 0:
            self.stem.y2 += 1
            for l in self.parts:
                l.y += 1
                if hasattr(l, 'y2'):
                    l.y2 += 1
            self.height += 1
            if(not self.blooming and self.height >= self.max_height//2):
                self.bloom()
            self.need_water()

    def wither(self):
        if self.parts:
            if len(self.parts) == 1:
                i = 0
            else:
                i = random.randint(0, len(self.parts)-1)
            self.parts[i].delete()
            del(self.parts[i])
            self.max_age += random.uniform(self.max_age*0.03, self.max_age*0.06)
        else:
            self.stem.delete()
            self.dead = True

    def update(self, dt):
        self.age += dt
        if self.age > self.max_age:
            self.wither()
        elif self.height < self.max_height:
            self.grow(dt)

class Human_body:
    batch = main_batch
    group = actors_plane

    def __init__(self, x, y, length, width, color):
        self.__dict__.update( locals() )
        del self.__dict__['self']
        self.part = pyglet.shapes.Line(x, y-length/2, x, y+length/2, width=width,
            color=color, batch=self.batch, group=self.group)

    def delete(self):
        self.part.delete()

    def move(self, dx, dy):
        self.x += dx
        self.y += dy
        self.part.x += dx
        self.part.x2 += dx
        self.part.y += dy
        self.part.y2 += dy

class Head:
    batch = main_batch
    group = actors_plane

    def __init__(self, x, y, width, color):
        self.__dict__.update( locals() )
        del self.__dict__['self']
        self.part = pyglet.shapes.Circle(x, y, width/2,
            color=color, batch=self.batch, group=self.group)

    def delete(self):
        self.part.delete()

    def move(self, dx, dy):
        self.x += dx
        self.y += dy
        self.part.x += dx
        self.part.y += dy

class Limb:
    batch = main_batch
    group = actors_plane
    def __init__(self, x, y, length, width, color):
        self.__dict__.update( locals() )
        del self.__dict__['self']
        self.part = pyglet.shapes.Line(self.x, self.y,
            self.x, self.y-self.length, width=self.width,
            color=self.color, batch=self.batch, group=self.group)
        self.angle = 0

    def delete(self):
        self.part.delete()

    def set_angle(self, angle):
        self.angle = angle
        radians = math.radians(270+angle)
        dx = math.cos(radians)*self.length
        dy = math.sin(radians)*self.length
        self.part.x2 = self.part.x+dx
        self.part.y2 = self.part.y+dy

    def align(self, goal, step):
        done = False
        a = self.angle
        sign = 1 if self.angle < goal else -1
        a += step*sign
        if (goal-a)*sign < 0:
            a = goal
            done = True
        self.set_angle(a)
        return done

    def move(self, dx, dy):
        self.x += dx
        self.y += dy
        self.part.x += dx
        self.part.x2 += dx
        self.part.y += dy
        self.part.y2 += dy



class Actor:
    batch = main_batch
    group = actors_plane
    size = 100
    width = 10
    body_color = (0,128,128)
    limb_color = (128,128,0)
    speedmax = 50

    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y
        self.parts = []
        self.actions = []

    def delete(self):
        for p in self.parts:
            p.delete()

    def move(self, dx, dy):
        self.x += dx
        self.y += dy
        for p in self.parts:
            p.move(dx, dy)

    def tag_active(self,tag):
        for a in self.actions:
            if tag in a['tags']:
                return 1

    def block_actions(self, tags, prio):
        bad = []
        for a in self.actions:
            for t in a['tags']:
                if t in tags:
                    if prio >= a.prio:
                        bad.append(a)
                        break
                    else:
                        return 0
        for a in bad:
            self.actions.remove[a]
        return 1

    def add_action(self, name, tags, prio=10):
        if not self.block_actions(tags, prio):
            return None
        sub = getattr(self,'a_'+name)
        action = {'name': name, 'sub': sub, 'tags': tags, 'prio': prio, 'phase': 0}
        self.actions.append(action)
        return action

    def end_action(self, action):
        if action in self.actions:
            self.actions.remove(action)

    def do_actions(self, dt):
        for a in self.actions:
            a['sub'](dt, a)

    def do_stop(self):
        action = self.add_action('stop', ['move','legs'], 10)
        if action:
            self.speed = self.speedmax

    def a_stop(self, dt, action):
        da = 100*self.speed/self.size*dt
        done = True
        for l in self.legs:
            done = l.align(0, da) and done
        if not self.tag_active('arms'):
            for l in self.arms:
                done = l.align(0, da) and done
        if done:
            self.end_action(action)

    def do_walk(self, x):
        action = self.add_action('walk', ['move', 'legs'], 10)
        if action:
            action['destx'] = x
            if (x-self.x)*self.dir < 0:
                self.dir = -self.dir
            self.speed = self.speedmax

    def limbs_angle(self, limbs, angle):
        for i in range(0,len(limbs),2):
            limbs[i].set_angle(angle)
        for i in range(1,len(limbs),2):
            limbs[i].set_angle(-angle)

    def a_walk(self, dt, action):
        dx = self.speed*dt*self.dir
        if (action['destx']-self.x-dx)*self.dir < 0:
            dx = action['destx']-self.x
            self.move(dx, 0)
            self.end_action(action)
            self.do_stop()
            return
        self.move(dx, 0)
        phase = action['phase']
        phasehalf = phasemax // 2
        angle = phase if phase < phasehalf else phasemax - phase
        angle = angle*180/4/phasehalf - 90/4
        self.limbs_angle(self.legs, angle)
        if not self.tag_active('arms'):
            self.limbs_angle(self.arms, angle)
        phase += self.speed * dt * phasemax / 100
        action['phase'] = phase % phasemax

    def do_promenade(self):
        action = self.add_action('promenade', ['goal'], 100)
        if action:
            action['now'] = None

    def a_promenade(self, dt, action):
        if action['now'] == 'idle':
            action['duration'] -= dt
            if action['duration'] <= 0 and not self.tag_active('move'):
                action['now'] = 'move'
                x = random.uniform(0, game_window.width)
                self.do_walk(x)
        elif action['now'] == 'move':
            if not self.tag_active('move'):
                action['now'] = ''
        else:
            action['now'] = 'idle'
            action['duration'] = random.uniform(2, 5)

    def update(self, dt):
        self.do_actions(dt)

class Human(Actor):

    def __init__(self, x=0, y=0, dir=1):
        super().__init__(x, y)
        self.dir=dir
        r = self.size/4
        ya = self.arms_level()
        yl = self.legs_level()
        a1 = Limb(x, ya, 2*r, width=self.width/2, color=self.limb_color)
        l1 = Limb(x, yl, r*10//4, width=self.width/2, color=self.limb_color)
        b = self.body = Human_body(x, y, r*2, self.width, self.body_color)
        h = self.head = Head(x, y+r+r//2, r, self.body_color)
        l2 = Limb(x, yl, 2.5*r, width=self.width/2, color=self.limb_color)
        a2 = Limb(x, ya, 2*r, width=self.width/2, color=self.limb_color)
        self.legs = [l1,l2]
        self.arms = [a1,a2]
        self.parts.extend((b,h,l1,l2,a1,a2))

    def arms_level(self):
        return self.y + self.size/4 - self.width/4

    def legs_level(self):
        return self.y - self.size/4 + self.width/2

    def ground(self):
        return self.legs_level() - self.legs[0].length



class Field:
    def __init__(self, y):
        self.y = y
        self.plants = []
        self.wait_next()

    def wait_next(self):
        self.wait = random.uniform(30, 60)

    def grow(self):
        x = random.randint(30, game_window.width-30)
        for p in self.plants:
            if abs(p.x-x) < 10:
                return
        self.plants.append( Flower(x, self.y, 0) )

    def update(self, dt):
        dead = []
        for i in self.plants:
            i.update(dt)
            if i.dead:
                dead.append(i)
        for i in dead:
            self.plants.remove(i)
        self.wait -= dt
        if self.wait < 0:
            self.grow()
            self.wait_next()



human1 = Human(100, 200)
human1.do_promenade()
flowers = Field(human1.ground() + 10)

def update(dt):
    t=str(datetime.datetime.now())
    time_label.text=t[11:19]
    date_label.text=t[:11]
    human1.update(dt)
    flowers.update(dt)
    if keyboard[key.UP]:
        human1.move(0, 10)
    elif keyboard[key.DOWN]:
        human1.move(0, -10)


if __name__ == '__main__':
    update(0)
    pyglet.clock.schedule_interval(update, 1/20)
    pyglet.app.run()
